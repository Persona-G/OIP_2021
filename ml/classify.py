# python classify.py --image sample_data/001.jpg

# imports
from openvino.inference_engine import IENetwork
from openvino.inference_engine import IEPlugin
import numpy as np
import argparse
import imutils
import time
import cv2

# construct argument
ap = argparse.ArgumentParser()
ap.add_argument("-i", "--image", required=True, help="path to the input image")
args = vars(ap.parse_args())

CLASSES = ["dirty", "clean", "wet"]

# grab the xml and bin files 
modelXML = "model/syringe.xml"
modelBin = "model/syringe.bin"

# initialize the inference engine plugin with MYRIAD device
plugin = IEPlugin("MYRIAD")

# read the IR generated by the Model Optimizer (.xml and .bin files)
print("Loading Model")
net = IENetwork(model=modelXML, weights=modelBin)

# prepare input and output blobs
print("Preparing Inputs")
inputBlob = next(iter(net.inputs))
outputBlob = next(iter(net.outputs))

# set the default batch size as 1 and grab the number of input blobs,
# number of channels, the height, and width of the input blob
net.batch_size = 1
(n, c, h, w) = net.inputs[inputBlob].shape

# load model to the plugin
print("Loading Model to the plugin")
execNet = plugin.load(network=net)

# load the input image and resize image to 500 to network size
orig = cv2.imread(args["image"])
orig = imutils.resize(orig, width=500)
image = cv2.resize(orig, (w, h))

# convert the image to a floating point data type and perform mean subtraction
blob = image.astype("float32")
mean = np.array([123.68, 116.779, 103.939][::-1], dtype="float32")
blob -= mean

blob = blob.transpose((2, 0, 1))  
blob = blob.reshape((n, c, h, w))

print("Classifying Image")

# get the starting time when it start the inference
start = time.time()
results = execNet.infer({inputBlob: blob})

# get the ending time when it ends the inference
end = time.time()
print("Classification took {:.4f} Seconds".format(end - start))
    
# top 5 predictions
results = results[outputBlob]
idxs = np.argsort(results.reshape((len(CLASSES))))[::-1][:5]

for (i, idx) in enumerate(idxs):
    
    # Prediction Probability
    proba = results[0][idx]

    # draw the top prediction on the input image
    if i == 0:

        # set the x,y coordinate and width,height of the black background
        x,y,w,h = 0,0,500,50
        
        # draw black background rectangle
        cv2.rectangle(orig, (x, x), (x + w, y + h), (0,0,0), -1)
        
        # add the text overlay on the black background
        text = "Label: {}, {:.2f}%".format(CLASSES[idx], proba * 100)
        cv2.putText(orig, text, (x + int(w/10),y + int(h/2)), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (174,180,242), 2)

    # display the predicted label + associated probability to the console
    print("{}. label: {}, probability: {:.2f}%".format(i + 1, CLASSES[idx], proba * 100))
    
# display the output image
cv2.imshow("Result", orig)
cv2.waitKey(0)